请求头信息 (Request Headers)
    ❖ Accept：浏览器可接受的 MIME 类型；
    ❖ Accept-Charset：浏览器可接受的字符集；
    ❖ Accept-Encoding：浏览器能够进行解码的数据编码方式，比如 gzip。Servlet 能够向支持 gzip
    的浏览器返回经 gzip 编码的 HTML 页面。许多情形下这可以减少 5 到 10 倍的下载时间；
    ❖ Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要
    用到；
    ❖ Authorization：授权信息，通常出现在对服务器发送的 WWW-Authenticate 头的应答中；
    ❖ Connection：表示是否需要持久连接。如果 Servlet 看到这里的值为“Keep-Alive”，或者看
    到请求使用的是 HTTP 1.1（HTTP 1.1 默认进行持久连接），它就可以利用持久连接的优点，
    当页面包含多个元素时（例如 Applet，图片），显著地减少下载所需要的时间。要实现这一
    点，Servlet 需要在应答中发送一个 Content-Length 头，最简单的实现方法是：先把内容写入
    ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；
    ❖ Content-Length：表示请求消息正文的长度；
    3.5 HTTP 请求过程 – 28 –
    ∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·∼·
    ❖ Cookie：这是最重要的请求头信息之一；也常用复数形式 Cookies, 这是网站为了辨别用户
    进行会话跟踪而存储在用户本地的数据它的主要功能是维持当前访问会话。例如，我们输
    入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次
    刷新或请求该站点的其他页面时，会发现都是登录状态，这就是 Cookies 的功劳 Cookies 里
    有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请
    求头中加上 Cookies 并将其发送给服务器，服务器通过 Cookies 识别出是我们自己，并且查
    出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容
    ❖ From：请求发送者的 email 地址，由一些特殊的 Web 客户程序使用，浏览器不会用到它；
    ❖ Host：初始 URL 中的主机和端口；
    ❖ If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回
    304“Not Modified”应答；
    ❖ Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器
    而且已经有了页面的本地拷贝；
    ❖ Referer：包含一个 URL，用户从该 URL 代表的页面出发访问当前请求的页面。此内容用来
    标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理如做来源
    统计、防盗链处理等
    ❖ User-Agent：浏览器类型，如果 Servlet 返回的内容与浏览器类型有关则该值非常有用；简称
    UA , 它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及
    版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出
    为爬虫
    ❖ UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的 IE 浏览器所发送的非标准的请求
    头，表示屏幕大小、颜色深度、操作系统和 CPU 类型
响应头信息 (Response Headers)

    ❖ Allow：服务器支持哪些请求方法（如 GET、POST 等）；
    ❖ Content-Encoding：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指
    定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream 可以很方便地进行 gzip 压缩，但只有 Unix 上的 Netscape 和 Windows 上的 IE 4、IE
    5 才支持它。因此，Servlet 应该通过查看 Accept-Encoding 头（即 request.getHeader("AcceptEncoding")）检查浏览器是否支持 gzip，为支持 gzip 的浏览器返回经 gzip 压缩的 HTML 页
    面，为其他浏览器返回普通页面；
    ❖ Content-Length：表示内容长度。只有当浏览器使用持久 HTTP 连接时才需要这个数据。如果
    你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大
    小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()
    发送内容；
    ❖ Content-Type：表示后面的文档属于什么 MIME 类型。Servlet 默认为 text/plain，但通常需要
    显式地指定为 text/html。由于经常要设置 Content-Type，因此 HttpServletResponse 提供了一
    个专用的方法 setContentTyep。可在 web.xml 文件中配置扩展名和 MIME 类型的对应关系；
    ❖ Date：当前的 GMT 时间。你可以用 setDateHeader 来设置这个头以避免转换时间格式的麻
    烦；
    ❖ Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。
    ❖ Last-Modified：文档的最后改动时间。客户可以通过 If-Modified-Since 请求头提供一个日期，
    该请求将被视为一个条件 GET，只有改动时间迟于指定时间的文档才会返回，否则返回一
    个 304（Not Modified）状态。Last-Modified 也可用 setDateHeader 方法来设置；
    ❖ Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse 的 sendRedirect 方法，该方法同时设置状态代码为 302； ❖ Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你
    还可以通过 setHeader("Refresh", "5; URL=http://host/path") 让浏览器读取指定的页面。注意
    这种功能通常是通过设置 HTML 页面 HEAD 区的 <META HTTP-EQUIV="Refresh" CONTENT="5;URL=http://host/path"> 实现，这是因为，自动刷新或重定向对于那些不能使用 CGI
    或 Servlet 的 HTML 编写者十分重要。但是，对于 Servlet 来说，直接设置 Refresh 头更加方便。
    注意 Refresh 的意义是“N 秒之后刷新本页面或访问指定页面”，而不是“每隔 N 秒刷新本
    页面或访问指定页面”。因此，连续刷新要求每次都发送一个 Refresh 头，而发送 204 状态代
    码则可以阻止浏览器继续刷新，不管是使用 Refresh 头还是 <META HTTP-EQUIV="Refresh"
    ...>。注意 Refresh 头不属于 HTTP 1.1 正式规范的一部分，而是一个扩展，但 Netscape 和 IE
    都支持它。